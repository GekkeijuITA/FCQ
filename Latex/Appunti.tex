\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\input{variables.tex}
\input{titlePage.tex}
\preamble

\begin{document}
\customTitlePage{Fondamenti di Computazione Quantistica}{Lorenzo Vaccarecci}{Anno Accademico 2024/2025}{Università degli Studi di Genova}
\newpage
\tableofcontents
\chapter{Fisica della computazione}
\section{Porte logiche universali}
\begin{itemize}
    \item \texttt{NOT(A)} $\equiv \bar{A}$
    \item \texttt{AND(A,B)} $\equiv A \cdot B$ oppure $A \land B$
    \item \texttt{OR(A,B)} $\equiv A + B$ oppure $A \lor B$
    \item \texttt{XOR(A,B)} $\equiv A \oplus B = (A+B) \mod 2$
    \item \texttt{NAND(A,B)} $\equiv \bar{A \cdot B}$ oppure $\bar{A \lor B}$
    \item \texttt{NOR(A,B)} $\equiv \bar{A + B}$ oppure $\bar{A \land B}$
\end{itemize}
L'insieme di \texttt{AND} e \texttt{NOT} oppure di \texttt{OR} e \texttt{NOT} sono insiemi universali. Questo significa che, ad esempio, usando solo combinazioni di porte \texttt{AND} e \texttt{NOT} è possibile implementare una qualsiasi funzione booleana. Pur formando set universali, le porte \texttt{AND}, \texttt{OR}, \texttt{NAND} e \texttt{NOR} sono però \textbf{irreversibili}. A livello concettuale è interessante introdurre delle porte logiche che siano \textbf{reversibili}. Questo vuol dire che se combiniamo in sequenza una porta logica reversibile con la sua inversa, riotteniamo l'informazione originale. La porta di Fredkin può essere interpretata come uno \textit{switch} controllato di bit. Il bit di controllo è \texttt{A}; se questo è acceso i bit \texttt{B} e \texttt{C} vengono scambiati, altrimenti vengono lasciati identici.
\begin{center}
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \texttt{A} & \texttt{B} & \texttt{C} & \texttt{Out1} & \texttt{Out2} & \texttt{Out3} \\
    \hline
    0 & 0 & 0 & 0 & 0 & 0 \\
    \hline
    0 & 0 & 1 & 0 & 0 & 1 \\
    \hline
    0 & 1 & 0 & 0 & 1 & 0 \\
    \hline
    0 & 1 & 1 & 0 & 1 & 1 \\
    \hline
    1 & 0 & 0 & 1 & 0 & 0 \\
    \hline
    1 & 0 & 1 & 1 & 1 & 0 \\
    \hline
    1 & 1 & 0 & 1 & 0 & 1 \\
    \hline
    1 & 1 & 1 & 1 & 1 & 1 \\
    \hline
    \end{tabular}
    \includegraphics[width=0.4\textwidth]{Immagini/fredkin_circuit.png}
\end{center}
\section{Operazioni Bit-a-Bit}
A una stringa di $n$ bit possiamo associare un intero compreso fra 0 e $N-1$ con $N=2^n$. All'intero $x$ associamo la stringa di bit $x_0x_1x_2\dots x_{n}$ con $x_{i}=0,1 \text{ e } i=0,1,\dots,n$ tale che $x=\sum_{i=0}^{n}x_{i}2^{n-i}$. Possiamo codificare $N=2^{n}$ interi ma questi saranno compresi fra 0 e $N-1=2^{n}-1$.
\subsection{Prodotto interno bit-per-bit}
\begin{equation*}
    x\cdot z \equiv (x_{1}z_{1} + x_{2}z_{2} + \dots + x_{n}z_{n}) \mod 2
\end{equation*}
E' anche chiamato prodotto \texttt{AND} bitwise perchè si ottiene prendendo le operazioni \texttt{AND} fra i singoli bit.
\subsection{Somma bit-per-bit: bitwise \texttt{XOR}}
Indichiamo con $x\oplus z$ la somma bit-per bit, modulo 2. Il risultato questa volta è una stringa il cui $i$-esimo bit ha il valore $x_{i}+z_{i} \mod 2 = x_{i} \text{ \texttt{XOR} } z_{i}$.
\chapter{Apparato matematico}
\section{Prerequisiti matematici}
\subsection{Numeri complessi}
Ogni numero complesso $z\in \mathbb{C}$ può essere scritto come $z=a+ib$, con $a\in \mathbb{R}$ \textbf{parte reale} e $b\in \mathbb{R}$ \textbf{parte immaginaria}. Se $z=a+ib$ e $w=c+id$, abbiamo
\begin{equation*}
    z+w = (a+c) + i(b+d)
\end{equation*}
\begin{equation*}
    z\cdot w = (ac-bd) + i(ad+bc)
\end{equation*}
Per ogni $z\in \mathbb{C}$, $z\cdot z^{*}=a^{2}+b^{2}$ è reale e non negativo dove $z^{*}$ è il \textbf{complesso coniugato} di $z$ (la parte complessa è negata). Inoltre, $\sqrt{a^{2}+b^{2}}=\lvert z\rvert$ è detto \textbf{modulo} di $z$.
\begin{equation*}
    \lvert z\rvert^{2} = z\cdot z^{*}
\end{equation*}
Possiamo rappresentare un numero complesso $z=a+ib$ come una coppia (a,b) sul piano complesso. L'asse delle ascisse è utilizzato per la parte reale e l'asse delle ordinate per la parte immaginaria. Si ha $a = \lvert z \rvert \cos \theta$ e $b = \lvert z \rvert \sin \theta$ dove $\theta$ è la \textbf{fase}. Se $z=0$ allora $\theta$ non è definita. Per $\lvert z \rvert = 1, z=\cos\theta + i\sin\theta$. Più in generale possiamo scrivere $z=pe^{i\theta}$ con $p=\lvert z \rvert$ e $e^{i\theta}=\cos\theta + i\sin\theta$.
\begin{equation*}
    i*(-i) = -1
\end{equation*}
\subsection{Spazi vettoriali in 2D}
\begin{itemize}
    \item \textbf{Direzione}: rappresentata dalla retta su cui giace il vettore
    \item \textbf{Verso}:  specifica in che direzione punta il vettore
\end{itemize}
Se abbiamo due vettori $u$ e $v$ possiamo definire la somma che sarà un vettore $w=u+v$ ottenuto mediante la \textbf{regola del parallelogramma}.\\
Dato un numero $\alpha\in \mathbb{R}$, per ogni vettore $v$, possiamo definire il vettore $\alpha v$ è la freccia ottenuta moltiplicando $v$ per $\alpha$ in modulo e lasciando invariata la direzione se $\alpha > 0$ e invertendo il verso se $\alpha < 0$. Questa operazione è detta \textbf{moltiplicazione per scalare}. Se $\alpha = -1$, otteniamo il vettore $-v$ che ha stesso modulo, stessa direzione ma verso opposto a $v$.\\
L'insieme di tutti i vettori del piano è allora uno spazio vettoriale reale $V$ chiuso rispetto all'operazione di combinazione lineare:
\begin{equation*}
    u = \alpha v + \beta w
\end{equation*}
Per ogni vettore $u$ e $v \in V$ e per ogni $\alpha, \beta \in \mathbb{R}$.
\subsection{Prodotto scalare e componenti}
\begin{equation*}
    < \cdot, \cdot > : V \times V \rightarrow \mathbb{C}
\end{equation*}
Che soddisfa le seguenti proprietà:
\begin{enumerate}
    \item $\forall u\in V, <u,u>$ è un numero reale non negativo, con $<u,u>=0 \iff u=0$
    \item $\forall u,v \in V, <u,v>=<v,u>^{*}$
    \item $\forall u,v,w \in V,\forall \alpha,\beta \in \mathbb{C}, <w,\alpha u+\beta v>=\alpha<w,u>+\beta<w,v>$
\end{enumerate}
Due vettori per i quali il prodotto scalare è nullo sono \textit{ortogonali}, sono base ortogonali se sono ortogonali e a norma unitaria ($\lVert <\cdot,\cdot>\rVert_{2}=1$).\\
Inoltre riscrivendo $u=u_{0}v_{0}+u_{1}v_{1}$ si ha:
\begin{equation*}
    <u,u>=<u_{0}v_{0}+u_{1}v_{1},u_{0}v_{0}+u_{1}v_{1}>=u_{0}^{2}+u_{1}^{2}
\end{equation*}
Dove $u_{0}=<u,v_{0}>$ e $u_{1}=<u,v_{1}>$
\subsection{Vettori ket e bra}
\begin{itemize}
    \item \textbf{Ket}: vettore $u \rightarrow |u\rangle$
    \item \textbf{Bra}: vettore $u \rightarrow \langle u|$
\end{itemize}
Usando questa notazione il prodotto scalare si forma con \textit{braket}:
\begin{equation*}
    <u,v>=\langle u|v\rangle
\end{equation*}
Usando la scomposizione di $v$ in componenti:
\begin{itemize}
    \item $|v\rangle = u_{0}|v_{0}\rangle + u_{1}|v_{1}\rangle$
    \item $\langle v| = u_{0}^{*}\langle v_{0}| + u_{1}^{*}\langle v_{1}|$
\end{itemize}
\subsubsection{Delta di Kronecker}
\begin{equation*}
    <v_{i},v_{j}> = \delta_{ij} = \begin{cases}
        1 & \text{se } i=j \\
        0 & \text{se } i\neq j
    \end{cases}
\end{equation*}
Usando queste notazioni possiamo scrivere il prodotto scalare come:
\begin{equation*}
    \begin{split}
        \langle v|v\rangle & = (u_{0}^{*}\langle v_{0}| + u_{1}^{*}\langle v_{1}|)\cdot (u_{0}|v_{0}\rangle + u_{1}|v_{1}\rangle) \\
        & = |u_{0}|^{2} \langle v_{0}|v_{0}\rangle + u_{0}^{*}u_{1}\langle v_{0}|v_{1}\rangle + u_{1}^{*}u_{0}\langle v_{1}|v_{0}\rangle + |u_{1}|^{2}\langle v_{1}|v_{1}\rangle \\
        & = |u_{0}|^{2}\cdot 1 + u_{0}^{*}u_{1} \cdot 0 + u_{1}^{*}u_{0} \cdot 0 + |u_{1}|^{2} \cdot 1 \\
        & = |u_{0}|^{2} + |u_{1}|^{2} \\
        & = | |v\rangle |^{2}
    \end{split}
\end{equation*}
\subsection{Prodotto tensore}
Consideriamo ora due spazi vettoriali $V$ e $W$ con basi, rispettivamente, $A=\left\{|\alpha_{1}\rangle_{V},\ldots,|\alpha_{n}\rangle_{V}\right\}$ e $B=\left\{|\beta_{1}\rangle_{W},\ldots,|\beta_{m}\rangle_{W}\right\}$. Da questa scrittura deduciamo che $V$ è uno spazio vettoriale di dimensione $n$ e $W$ di dimensione $m$.\\
Il prodotto tendore di $V$ e $W$ viene indicato con $V\otimes W$ ha dimensione $\dim(V\otimes W)=n\text{ }m$  con la base costituita da $n\text{ }m$ elementi della forma $|\alpha_{i}\rangle_{V}\otimes|\beta_{j}\rangle_{W}$.\\
\textbf{La notazione $|\alpha_{i}\rangle_{V}\otimes|\beta_{j}\rangle_{W}$ può essere scritta come $|\alpha_{i}\beta_{j}\rangle$}.\\
Proprietà:
\begin{enumerate}
    \item $\forall \ket{v},\ket{v'} \in V, \ket{w} \in W \quad (\ket{v}+\ket{v'})\otimes\ket{w} = \ket{v}\otimes\ket{w}+\ket{v'}\otimes\ket{w}$
    \item $\forall\ket{v}\in V, \ket{w},\ket{w'}\in W \quad \ket{v}\otimes (\ket{w}+\ket{w'})=\ket{v}\otimes\ket{w}+\ket{v}\otimes\ket{w'}$
    \item $\forall\ket{v}\in V,\ket{w}\in W,\alpha \in \mathbb{C} \quad (\alpha\ket{v})\otimes\ket{w}=\ket{v}\otimes(\alpha\ket{w})=\alpha(\ket{v}\otimes\ket{w})$
\end{enumerate}
Se $V$ e $W$ ammettono prodotto scalare, allora $V\otimes W$ ammette un prodotto scalare definito come:
\begin{equation*}
    \braket{u}{u'}=(\bra{v}\otimes\bra{w})\cdot(\ket{v'}\otimes\ket{w'})=\braket{v}{v'}\cdot\braket{w}{w'} \in \mathbb{C}
\end{equation*}
Alcune "proprietà":
\begin{enumerate}
    \item $(\bra{\alpha_{1}}\otimes\bra{\beta_{2}})\cdot(\ket{\alpha_{1}}\otimes\ket{\beta_{2}}) = \braket{\alpha_{1}}{\alpha_{1}}\cdot\braket{\beta_{2}}{\beta_{2}}=1$
    \item $\left\{\ket{\alpha_{i}}\otimes\ket{\beta_{j}}\right\}$ è una base ortonormale $V\otimes W$ \begin{itemize}
        \item Se $\braket{\alpha_{i}}{\alpha_{k}}\cdot\braket{\beta_{j}}{\beta_{l}}=1 \rightarrow \text{normalizzati}$
        \item Se $\braket{\alpha_{i}}{\alpha_{k}}\cdot\braket{\beta_{j}}{\beta_{l}}=0 \rightarrow \text{ortogonali}$
    \end{itemize}
\end{enumerate}
\subsubsection{Esempio}
$\ket{v} = a\ket{\alpha_{1}}_{V}+b\ket{a_{2}}_{V}\in V$\\
$\ket{w} = c\ket{\beta_{1}}_{W}+d\ket{\beta_{2}}_{W}\in W$ 
\begin{equation*}
    \begin{split}
        \ket{v}\otimes\ket{w} & = (a\ket{\alpha_{1}}_{V}+b\ket{\alpha_{2}}_{V})\otimes(c\ket{\beta_{1}}_{W}+d\ket{\beta_{2}}_{W}) \\
        & = ac(\ket{\alpha_{1}}_{V}\otimes\ket{\beta_{1}}_{W})+ad(\ket{\alpha_{1}}_{V}\otimes\ket{\beta_{2}}_{W})+bc(\ket{\alpha_{2}}_{V}\otimes\ket{\beta_{1}}_{W})+bd(\ket{\alpha_{2}}_{V}\otimes\ket{\beta_{2}}_{W}) \\
        \bra{v}\otimes\bra{w} & = (a\bra{\alpha_{1}}_{V}+b\bra{\alpha_{2}}_{V})\otimes(c\bra{\beta_{1}}_{W}+d\bra{\beta_{2}}_{W}) \\
        & = ac(\bra{\alpha_{1}}_{V}\otimes\bra{\beta_{1}}_{W})+ad(\bra{\alpha_{1}}_{V}\otimes\bra{\beta_{2}}_{W})+bc(\bra{\alpha_{2}}_{V}\otimes\bra{\beta_{1}}_{W})+bd(\bra{\alpha_{2}}_{V}\otimes\bra{\beta_{2}}_{W})
    \end{split}
\end{equation*}
\footnotesize
\begin{equation*}
    \begin{split}
        (\bra{v}\otimes\bra{w})\cdot(\ket{v}\otimes\ket{w}) & = [(a\bra{\alpha_{1}}_{V}+b\bra{\alpha_{2}}_{V})\otimes(c\bra{\beta_{1}}_{W}+d\bra{\beta_{2}}_{W})]\cdot[(a\ket{\alpha_{1}}_{V}+b\ket{\alpha_{2}}_{V})\otimes(c\ket{\beta_{1}}_{W}+d\ket{\beta_{2}}_{W})] \\
        & = \\
        & = (|a|^{2}+|b|^{2})\cdot(|c|^{2}+|d|^{2})
    \end{split}
\end{equation*}
\normalsize
\subsection{Operatori lineari}
Gli operatori lineari in generale sono tali che agendo su un vettore dello spazio lineare danno un altro vettore dello stesso spazio: $O:V\rightarrow V$. Usando la notazione braket possiamo scrivere \begin{equation*}
    O\ket{v}=\ket{w}
\end{equation*}
Scegliamo una base (ortonormale) dello spazio vettoriale $\left\{\ket{\alpha_{1}},\ldots,\ket{\alpha_{n}}\right\}$, l'elemento della matrice $O$ in posizione $(i,j)$ sarà $O_{ij}=\bra{\alpha_{i}}\cdot(O\ket{\alpha_{j}})$
\subsubsection{Esempio}
Voglio calcolare $O_{12}$:
\begin{equation*}
    \begin{split}
        O_{12} & =\bra{\alpha_{1}}\left(\sum_{ij}^{n}O_{ij}\ket{\alpha_{i}}\bra{\alpha_{j}}\right)\ket{\alpha_{2}}\\
        & = \sum_{ij}^{n} O_{ij}\braket{\alpha_{1}}{\alpha_{i}}\braket{\alpha_{j}}{\alpha_{2}} \\
        & = O_{12}
    \end{split}
\end{equation*}
Grazie al delta di Kronecker.
\subsection{Autovalori e Autovettori}
Diremo che se $O\ket{v}=\lambda\ket{v}$ per un vettore non nullo $\ket{v}$, diremo che $v$ è un \textbf{autovettore} di O e $\lambda$ è l'\textbf{autovalore} corrispondente.
\chapter{Introduzione ai fenomeni quantistici}
Un osservabile fisico può essere associato ad un operatore Hermittiano $\phi$ da cui possiamo ottenere i loro autovalori e autovettori. Il punto fondamentale di questa discussione è che la base, gli autovalori e il risultato dipende dall'osservabile che vogliamo misurare.
\section{Regole dal postulato della misura}
\begin{enumerate}
    \item Se vogliamo misurare un osservabile $\phi$, dobbiamo conoscere i suoi autovalori $\{\phi_{i}\}$ e autovettori $\{\ket{\phi_{i}}\}$; cioè gli stati tali che $\phi\ket{\phi_{i}}=\phi_{i}\ket{\phi_{i}}$. Gli autovettori saranno la base su cui decomporre lo stato del nostro sistema. Ovvero dobbiamo scrivere $\ket{a}=\sum_{i}a_{i}\ket{\phi_{i}}$ con $a_{i}=\braket{\phi_{i}}{a}$.
    \item La misura avrà come risultato l'autovalore $\phi_{i}$ con probabilità $|a_{i}|^{2}$.
    \item Dopo la misura, il sistema si troverà nello stato $\ket{\phi_{i}}$ associato all'autovalore misurato.
\end{enumerate}
Stati quantistici sono normalizzati:
\begin{equation*}
    \sum_{i=1}^{N}|a_{i}|^{2}=1
\end{equation*}
\section{Fase globale e relativa}
\subsection{Fase globale}
Consideriamo i vettori $\ket{u}$ e $e^{i\phi}\ket{u}$ che hanno lo stesso modulo ma differiscono per una fase globale $\phi$. Il calcolo delle probabilità dei risultati di una qualunque misura fornisce sempre gli stessi valori.\\
Sia $\ket{u}\sum_{i}\alpha_{i}\ket{\phi_{i}}$ dove $\{\ket{\phi_{i}}\}$ formano una base ortonormale dello spazio vettoriale. Lo stato con una fase globale si scriverà $e^{i\phi}\ket{u}=\sum_{i}e^{i\phi}\alpha_{i}\ket{\phi_{i}}$
\subsubsection{Esempio di fase globale/relativa}
\begin{equation*}
    \tikzmark{ephi}e^{i\phi}\frac{(\ket{0}+\tikzmark{ephigamma}e^{i(\gamma - \phi)}\ket{1})}{\sqrt{2}}
\end{equation*}
\begin{tikzpicture}[overlay, remember picture]
    \node (ephi-desc) [below of= ephi] {Fase globale};
    \draw[<-] (ephi.south)++(.25em,-.5ex) -- (ephi-desc);
    \node (ephigamma-desc) [above of= ephigamma] {Fase relativa};
    \draw[<-] (ephigamma.north)++(.25em,2ex) -- (ephigamma-desc);
\end{tikzpicture}
\section{Stati a molti qubit}
\begin{itemize}
    \item \textbf{Base del qubit}: $\{\ket{0},\ket{1}\}$
    \item \textbf{Stato}: $\ket{\psi}=\alpha\ket{0}+\beta\ket{1}$
\end{itemize}
Consideriamo:
\begin{equation}
    \begin{split}
        &\text{A: } \ket{\psi} = \alpha\ket{0}+\beta\ket{1} \\
        &\text{B: } \ket{\phi} = \gamma\ket{0}+\delta\ket{1}
    \end{split}
\end{equation}
La base $B$ la otteniamo con:
\begin{equation*}
    \begin{split}
        \ket{\psi}\oplus\ket{\phi} &= \left(\alpha\ket{0}+\beta\ket{1}\right)\oplus\left(\gamma\ket{0}+\delta\ket{1}\right)\\
        &= \alpha\gamma\ket{00}+\alpha\delta\ket{01}+\beta\gamma\ket{10}+\beta\delta\ket{11}
    \end{split}
\end{equation*}
Per ricavare la base ci fermiamo al secondo passaggio, quindi avremo $B:\left\{\ket{00},\ket{01},\ket{10},\ket{11}\right\}$.
\subsection{Stati a due qubit separabili}
Usando $\ket{\psi}$ e $\ket{\phi}$ (3.1), a volte conviene scrivere lo stato come:
\begin{equation*}
    \ket{\psi}\oplus\ket{\phi} = \alpha\ket{0} \oplus \left(\gamma\ket{0}+\delta\ket{1}\right) + \beta\ket{1} \oplus \left(\gamma\ket{0}+\delta\ket{1}\right)
\end{equation*}
Perchè in questo modo si possono determinare le probabilità di collasso in modo più semplice:
\begin{equation*}
    \begin{cases}
        \text{Se collassa $\alpha$: } |\alpha|^{2},\phi_{0} \rightarrow \ket{0}\oplus\left(\gamma\ket{0}+\delta\ket{1}\right) = \begin{cases}
            \text{Se collassa $\gamma$: } |\gamma|^{2},\phi_{0}\rightarrow \ket{00}\\
            \text{Se collassa $\delta$: } |\delta|^{2},\phi_{1}\rightarrow \ket{01}
        \end{cases}\\
        \text{Se collassa $\beta$: } |\beta|^{2},\phi_{1} \rightarrow \ket{1}\oplus\left(\gamma\ket{0}+\delta\ket{1}\right) = \begin{cases}
            \text{Se collassa $\gamma$: } |\gamma|^{2},\phi_{0}\rightarrow \ket{10}\\
            \text{Se collassa $\delta$: } |\delta|^{2},\phi_{1}\rightarrow \ket{11}
        \end{cases}\\
    \end{cases}
\end{equation*}
\subsubsection{Esempio}
\begin{equation*}
    \begin{split}
        \ket{\varepsilon} &= \frac{1}{\sqrt{2}}\left(\ket{01}+\ket{10}\right) ?= \ket{\psi} \oplus \ket{\phi} \\
        &= \frac{1}{\sqrt{2}}\left(\ket{01}\right) + \frac{1}{\sqrt{2}}\left(\ket{10}\right) = \begin{cases}
            \text{Se collassa $\ket{01}$: } \frac{1}{2}, \phi_{0} \rightarrow \ket{01} \rightarrow 1,\phi_{0} \rightarrow \ket{01}\\
            \text{Se collassa $\ket{10}$: } \frac{1}{2}, \phi_{1} \rightarrow \ket{10} \rightarrow 1,\phi_{1} \rightarrow \ket{10}
        \end{cases}
    \end{split}
\end{equation*}
Possiamo dedurre che se A misura 0, B misura 1 e viceversa.
\subsection{Stati a due qubit entangled}
Gli elementi dello spazio vettoriale $A\oplus B$ non sono tutti ottenibili come prodotto tensoriale di due elementi di $A$ e $B$. \\
Un esempio di stati entangled sono gli stati di Bell:
\begin{equation*}
    \begin{split}
        &\ket{\phi^{+}} = \frac{1}{\sqrt{2}}\left(\ket{0}_{A}\oplus\ket{0}_{B}+\ket{1}_{A}\oplus\ket{1}_{B}\right) \\
        &\ket{\phi^{-}} = \frac{1}{\sqrt{2}}\left(\ket{0}_{A}\oplus\ket{0}_{B}-\ket{1}_{A}\oplus\ket{1}_{B}\right) \\
        &\ket{\psi^{+}} = \frac{1}{\sqrt{2}}\left(\ket{0}_{A}\oplus\ket{1}_{B}+\ket{1}_{A}\oplus\ket{0}_{B}\right) \\
        &\ket{\psi^{-}} = \frac{1}{\sqrt{2}}\left(\ket{0}_{A}\oplus\ket{1}_{B}-\ket{1}_{A}\oplus\ket{0}_{B}\right) \\
    \end{split}
\end{equation*}
Per descrivere lo stato di un sistema a due qubit possiamo alternativamente usare la base canonica $\left\{\ket{00},\ket{01},\ket{10},\ket{11}\right\}$ o la base di Bell $\left\{\ket{\phi^{+}},\ket{\phi^{-}},\ket{\psi^{+}},\ket{\psi^{-}}\right\}$.
\begin{equation*}
    O = \lambda_{0}\ket{\phi^{+}}\braket{\phi^{+}}[+\lambda_{1}]{\phi^{-}}\braket{\phi^{-}}[+\lambda_{2}]{\psi^{+}}\braket{\psi^{+}}[+\lambda_{3}]{\psi^{-}}\bra{\psi^{-}}
\end{equation*}
Quindi se il sistema si trova in uno stato di Bell, una misura dell'operatore $O$ darà con certezza l'autovalore corrispondente.
\section{Trasformazioni unitarie}
Sia $\ket{a} = \alpha\ket{x_{0}}+\beta\ket{x_{1}}$, una trasformazione  unitaria $U$ è
\begin{itemize}
    \item \textbf{Lineare}: $U\ket{a}=U(\alpha\ket{x_{0}}+\beta\ket{x_{1}}) = \alpha U\ket{x_{0}}+\beta U\ket{x_{1}}$
    \item \textbf{Invertibile  con l'inversa uguale alla trasposta coniugata}: $U^{-1}\ket{a}=U^{\dagger}\ket{a}$
\end{itemize}
Quest'ultima proprietà garantice che le trasformazioni unitarie laasciano invariati i prodotti scalari, e quindi anche la norma dei vettori su cui agiscono e le probabilità associate alle misure. Infatti, prendiamo due stati $\ket{a}$ e $\ket{b}$ con prodotto scalare $\braket{b}{a}$. Se questi evolvono secondo un operatore unitario $U$ avremo $\ket{a'}=U\ket{a}$ e $\ket{b'}=U\ket{b}$ ($\bra{b'}=\bra{b}U^{\dagger}$), il prodotto scalare degli stati evoluti sarà $\braket{b'}{a'}=\braket{b}[U^{\dagger}U]{a}=\braket{b}{a}$ perchè $U^{\dagger}U=\text{Identità}$.
\subsection{Porte quantistiche}
\subsubsection{Trasformazioni di Pauli}
Nel nostro caso scegliamo la base canonica $\left\{\ket{0},\ket{1}\right\}$ e definiamo, oltre all'identità $Id$, le tre trasformazioni di Pauli $X,Y,Z$:
\begin{equation*}
    \begin{alignedat}{2}
        Id\ket{0} &\,:=\, \ket{0} \quad & Id\ket{1} &\,:=\, \ket{1} \\
        X\ket{0}  &\,:=\, \ket{1} \quad & X\ket{1}  &\,:=\, \ket{0} \\
        Y\ket{0}  &\,:=\,-i\ket{1} \quad & Y\ket{1} &\,:=\, i\ket{0} \\
        Z\ket{0}  &\,:=\,-\ket{0} \quad & Z\ket{1} &\,:=\, \ket{1}
    \end{alignedat}
\end{equation*}
Analizzando l'effetto degli operatori, si nota che nella base canonica, $X$ corrisponde al \texttt{NOT} tra bit classici. L'operatore $Z$ genera un cambio della fase relativa e, infine, l'operatore $Y$ può essere visto come una combinazione dei due precedenti dato che $Y=-iXZ$.\\
\textbf{Esempio}
\begin{equation*}
    \begin{split}
        Z\left(\alpha\ket{0}+\beta\ket{1}\right) &= \alpha Z\ket{0}+\beta Z\ket{1} \\
        &= -\alpha\ket{0}+\beta\ket{1}
    \end{split}
\end{equation*}
\subsubsection{Trasformazioni di Hadarmard}
\begin{equation*}
    \begin{split}
        H\ket{0} &= \ket{+} = \frac{(\ket{0}+\ket{1})}{\sqrt{2}} \\
        H\ket{1} &= \ket{-} = \frac{(\ket{0}-\ket{1})}{\sqrt{2}}
    \end{split}
\end{equation*}
In forma matriciale (nella base canonica $\left\{\ket{0},\ket{1}\right\}$) l'operatore di Hadarmard si scrive come:
\begin{equation*}
    H = \frac{1}{\sqrt{2}}
    \begin{pmatrix}
        1 & 1 \\
        -1 & 1
    \end{pmatrix}
\end{equation*}
\subsubsection{Controlled-NOT}
Consideriamo ora, il controlled-NOT, \texttt{CNOT}, una trasformazione che agisce su 2 qubit, $A$ e $B$. Nella base canonica l'azione del \texttt{CNOT} é:
\begin{equation*}
    \begin{split}
        CNOT \ket{0}_{A}\oplus \ket{0}_{B} &= \ket{0}_{A}\oplus \ket{0}_{B} \\
        CNOT \ket{0}_{A}\oplus \ket{1}_{B} &= \ket{0}_{A}\oplus \ket{1}_{B} \\
        CNOT \ket{1}_{A}\oplus \ket{0}_{B} &= \ket{1}_{A}\oplus \ket{1}_{B} \\
        CNOT \ket{1}_{A}\oplus \ket{1}_{B} &= \ket{1}_{A}\oplus \ket{0}_{B} 
    \end{split}
\end{equation*}
In linea generale possiamo scrivere il \texttt{CNOT} come:
\begin{equation*}
    C_{i}NOT_{j}
\end{equation*}
Dove $i$ è il qubit di controllo e $j$ il qubit target. Se il qubit di controllo è acceso allora applica un \texttt{NOT} al qubit target.\\
L'importanza dell'operatore \texttt{CNOT} risiede nel fatto che può generare entanglement fra due qubit.\\
\textbf{Esempio}
\begin{equation*}
    \ket{00} \xrightarrow{H_{1}} \frac{\ket{0}+\ket{1}}{\sqrt{2}} \oplus \ket{0} = \frac{1}{\sqrt{2}}\left(\ket{00}+\ket{10}\right) \xrightarrow{C_{1}NOT_{2}} \frac{1}{\sqrt{2}}\left(\ket{00}+\ket{11}\right) = \text{Stato di Bell}
\end{equation*}
\customfbox{Se eseguo l'operatore \texttt{CNOT} due volte ottengo lo stato iniziale: \begin{equation*}
    CNOT^{2} = Id
\end{equation*}}
\section{Sfera di Bloch}
Come detto un generico stato quantistico a due livelli o qubit è scritto come $\ket{v}=\alpha\ket{0}+\beta\ket{1}$ con il vincolo ulteriore di normalizzazione dello stato: $\lvert \alpha \rvert^{2} + \lvert \beta \rvert^{2} = 1$. Quindi in generale possiamo scrivere $\lvert \alpha \rvert^{2}=\cos^{2}\left(\theta\right) \rightarrow \lvert \alpha \rvert=\cos\left(\frac{\theta}{2}\right)$ e $\lvert \beta \rvert^{2}=\sin^{2}\left(\theta\right) \rightarrow \lvert \beta \rvert=\sin\left(\frac{\theta}{2}\right)$
Possiamo rappresentare gli stati dei qubit in modo geometrico. Consideriamo lo stato generico
\begin{equation*}
    \ket{\psi} = \cos\left(\frac{\theta}{2}\right)\ket{0}+\sin\left(\frac{\theta}{2}\right)e^{i\phi}\ket{1}
\end{equation*}
e il relativo stato bra
\begin{equation*}
    \bra{\psi} = \cos\left(\frac{\theta}{2}\right)\bra{0}+\sin\left(\frac{\theta}{2}\right)e^{-i\phi}\bra{1}    
\end{equation*}
Calcoliamo i valori medi degli operatori di Pauli $X,Y,Z$ con lo stato $\ket{\psi}$
\begin{equation*}
    \begin{split}
        x &= \braket{\psi}[X]{\psi} = \cos \phi \sin \theta \\
        y &= \braket{\psi}[Y]{\psi} = \sin \phi \sin \theta \\
        z &= \braket{\psi}[Z]{\psi} = \cos \theta \text{ (oppure $-\cos \theta$)}
    \end{split}
\end{equation*}
Queste non sono altro che le coordinate in uno spazio tridimensionale di un punto che si muove su una sfera. Se consideriamo il vettore che congiunge l'origine degli assi con il punto di coordinate $\{x,y,z\}$, l'angolo $\theta$ è quello formato dal vettore e dall'asse $z$ mentre l'angolo $\phi$ è quello formato dal vettore sul piano $y-z$
\begin{center}
    \includegraphics[width=0.5\textwidth]{Immagini/sferadibloch.png}
\end{center}
Concludiamo che ogni operatore unitario può essere visto come una rotazione sulla sfera di Bloch che unisce lo stato iniziale con lo stato finale.\\
L'operatore $U$ possiamo scriverlo più generalmente come:
\begin{equation*}
    U = \cos\left(\frac{\alpha}{2}\right)Id - i\sin\left(\frac{\alpha}{2}\right)Y
\end{equation*}
\textbf{Esempio}
\begin{equation*}
    \begin{split}
        \ket{\psi} &= \ket{1} \\
        \ket{\psi_{f}} &= U\ket{\psi} \\
        &= \cos\left(\frac{\alpha}{2}\right)Id\ket{1}-i\sin\left(\frac{\alpha}{2}\right)Y\ket{1} \\
        &= \cos\left(\frac{\alpha}{2}\right)\ket{1}-i\sin\left(\frac{\alpha}{2}\right)i\ket{0} \\
        &= \cos\left(\frac{\alpha}{2}\right)\ket{1}+\sin\left(\frac{\alpha}{2}\right)\ket{0} \\
    \end{split}
\end{equation*}
\chapter{Informazione Quantistica}
\section{Parallelismo quantistico}
Supponiamo di partire dai due qubit inizializzati nello stato $\ket{00}\equiv\ket{0}\otimes\ket{0}$ e di applicare due porte di Hadarmard ai singoli qubit. Le due porte applicate contemporaneamente si denotano come $H\otimes H\equiv H^{\otimes 2}$ dove la notazione $\otimes$ indica che la prima porta è applicata al primo qubit e la seconda al secondo qubit
\begin{equation*}
    \begin{split}
        \ket{0}\otimes\ket{0}\xrightarrow{H^{\otimes 2}} \frac{\ket{0}+\ket{1}}{\sqrt{2}}\otimes\frac{\ket{0}+\ket{1}}{\sqrt{2}} &= \frac{\ket{00}}{2}+\frac{\ket{01}}{2}+\frac{\ket{10}}{2}+\frac{\ket{11}}{2} \\
        &= \frac{1}{2}\left(\ket{00}+\ket{01}+\ket{10}+\ket{11}\right)
    \end{split}
\end{equation*}
Se applichiamo un operatore unitario $U$
\begin{equation*}
    \begin{split}
        \frac{1}{2}\left(\ket{00}+\ket{01}+\ket{10}+\ket{11}\right)\xrightarrow{U}\frac{1}{2}\left(U\ket{00}+U\ket{01}+U\ket{10}+U\ket{11}\right)
    \end{split}
\end{equation*}
Ovvero agirà contemporaneamente su tutti gli stati logici. Questo ragionamento si estende in maniera semplice al caso di $n$ qubit. In questo caso lo stato iniziale sarà $\ket{00\ldots 0}$ e applicheremo $n$ porte di Hadarmard $H^{\otimes n}$
\begin{equation*}
    \begin{split}
        \ket{00\ldots 0} \xrightarrow{H^{\otimes n}} \frac{\ket{0}+\ket{1}}{\sqrt{2}}\otimes\dots\otimes\frac{\ket{0}+\ket{1}}{\sqrt{2}} &= \frac{1}{2^{\frac{n}{2}}}\left(\ket{00\ldots 0}+\ket{10\ldots 0}+\ldots+\ket{11\ldots 1}\right) \\
        &= \frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}\ket{x}
    \end{split}
\end{equation*}
Dove $N=2^{n}$ e anche in questo caso, applicando successivamente un operatore unitario $U$ avremo
\begin{equation*}
    \frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}U\ket{x}
\end{equation*}
Possiamo manipolare parallelamente tutte le $N$ stringhe logiche.
\section{Teorema no-cloning}
Supponiamo di avere un singolo qubit di informazione e che si trovi nello stato $\ket{\psi}=a\ket{0}+b\ket{1}$ (con $|a|^{2}+|b|^{2}=1$). Per copiarlo, prendiamo un secondo qubit inizializzato nello stato $\ket{0}$. Avremo $\ket{\psi0}=a\ket{00}+b\ket{10}$ e applichiamo la porta \texttt{CNOT}
\begin{equation*}
    \ket{\psi0}=a\ket{00}+b\ket{10}\xrightarrow{C_{1}NOT_{2}} a\ket{00}+b\ket{11}
\end{equation*}
Se consideriamo lo stato più generale $\ket{\psi0}=a\ket{00}+b\ket{10}$ per copiarlo dovremmo avere un operatore il cui risultato sia
\begin{equation*}
    \ket{\psi\psi} = a^{2}\ket{00}+ab\ket{01}+ab\ket{10}+b^{2}\ket{11}
\end{equation*}
\customfbox{Se lo stato da copiare è sconosciuto, non è possibile copiarlo.}
L'operazione di copiatura sarà descritta da un'evoluzione unitaria $U_{COPY}$ tale che
\begin{equation*}
    \ket{\psi s}\xrightarrow{U_{COPY}}\ket{\psi s}=\ket{\psi\psi}
\end{equation*}
Supponiamo di voler copiare anche uno stato $\ket{\varphi}$ 
\begin{equation*}
    \ket{\varphi s}\xrightarrow{U_{COPY}}\ket{\varphi s}=\ket{\varphi\varphi}
\end{equation*}
Se prendendo il prodotto scalare degli stati finali abbiamo
\begin{equation*}
    \braket{\varphi s}[U^{\dagger}_{COPY}U_{COPY}]{\psi s} = \braket{\varphi s}{\psi s} = \braket{\varphi}{\psi}\braket{s}{s} = \braket{\varphi}{\psi}
\end{equation*}
\textbf{Esempio}\\
$s = 0$
\begin{equation*}
    \begin{split}
      \bra{\varphi}\bra{0}U^{\dagger}_{COPY}\left(U_{COPY}\ket{\psi}\ket{0}\right) &= \bra{\varphi}\bra{0}I\ket{\psi}\ket{0} \\
      &= \left(\bra{\varphi}\bra{0}\right)\left(\ket{\psi}\ket{0}\right) \\
      &= \braket{\varphi}{\psi}\braket{0}{0} \\
      &= \braket{\varphi}{\psi}
    \end{split}
\end{equation*}
Dalle equazioni di sopra, questo deve essere uguale a $\braket{\psi\psi}{\varphi\varphi} = \braket{\varphi}{\psi}\braket{\varphi}{\psi}$
\begin{equation*}
    \braket{\varphi}{\psi} = \left(\braket{\varphi}{\psi}\right)^{2}
\end{equation*}
Quindi può esistere un operatore unitario di copia $U_{COPY}$ solo se gli stati $\ket{psi}$ e $\ket{\varphi}$ sono ortogonali ($\braket{\varphi}{\psi} = 0$) oppure identici ($\braket{\varphi}{\psi} = 1$).\\
Concludiamo che se gli stati da copiare sono noti e ortogonali è possibile costruire un operatore unitario $U_{COPY}$ che li copi. In genere, però non è possibile copiare stati quantistici qualsiasi; ovvero non esiste nessun operatore $U_{COPY}$ capace di copiare tutti gli stati quantistici. 
\section{Superdense coding}
Supponiamo che Alice voglia mandare due bit di informazione classica. Alice e Bob devono condividere uno stato entangled (di Bell)
\begin{equation*}
    \ket{\beta_{00}} = \frac{1}{\sqrt{2}}\left(\ket{0}_{A}\otimes\ket{0}_{B}+\ket{1}_{A}\otimes\ket{1}_{B}\right)
\end{equation*}
Dove gli stati $\ket{\ldots}_{A}$ e $\ket{\ldots}_{B}$ sono rispettivamente di Alice e Bob.
\begin{center}
    \begin{tabular}{| c | c | c |}
        \hline
        \textbf{Bit di Alice} & \textbf{Porta logica applicata} & \textbf{Stato di Bob} \\
        \hline
        00 & $I$ & $\frac{\left(\ket{00}_{B}+\ket{11}_{B}\right)}{\sqrt{2}} \xrightarrow{C_{1}NOT_{2}} \frac{\left(\ket{00}_{B}+\ket{10}_{B}\right)}{\sqrt{2}} \xrightarrow{H} \ket{00}_{B}$ \\
        \hline
        01 & $X$ & $\frac{\left(\ket{10}_{B}+\ket{01}_{B}\right)}{\sqrt{2}} \xrightarrow{C_{1}NOT_{2}} \frac{\left(\ket{11}_{B}+\ket{01}_{B}\right)}{\sqrt{2}} \xrightarrow{H} \ket{01}_{B}$ \\
        \hline
        10 & $Z$ & $\frac{\left(\ket{00}_{B}-\ket{11}_{B}\right)}{\sqrt{2}} \xrightarrow{C_{1}NOT_{2}} \frac{\left(\ket{00}_{B}-\ket{10}_{B}\right)}{\sqrt{2}} \xrightarrow{H} \ket{10}_{B}$ \\
        \hline
        11 & $iY$ & $\frac{\left(\ket{01}_{B}-\ket{10}_{B}\right)}{\sqrt{2}} \xrightarrow{C_{1}NOT_{2}} \frac{\left(\ket{01}_{B}-\ket{11}_{B}\right)}{\sqrt{2}} \xrightarrow{H} \ket{11}_{B}$ \\
        \hline
    \end{tabular}
\end{center}
\section{Teletrasporto quantistico}
Supponiamo che Alice (A) e Bob (B) condividano uno stato entangled $\ket{\beta_{00}} = \frac{\ket{00}+\ket{11}}{\sqrt{2}}$. Questa notazione sta per la più precisa
\begin{equation*}
    \ket{\beta_{00}} = \frac{1}{\sqrt{2}}\left(\ket{0}_{A}\otimes\ket{0}_{B}+\ket{1}_{A}\otimes\ket{1}_{B}\right) = \frac{1}{\sqrt{2}}\left(\ket{00}+\ket{11}\right)
\end{equation*}
Supponiamo che Alice abbia aun qubit di informazione $\ket{\psi} = \alpha\ket{0}+\beta\ket{1}$ (con $\lvert \alpha \rvert^{2}+\lvert \beta \rvert^{2}=1$) che vuole mandare a Bob. Per far questo, lo accoppia allo stato entangled $\ket{\beta_{00}}$
\begin{equation*}
    \ket{\psi_{0}} = \ket{\psi}\ket{\beta_{00}} = \frac{1}{\sqrt{2}}\left[\alpha\ket{0}(\ket{00}+\ket{11})+\beta\ket{1}(\ket{00}+\ket{11})\right]
\end{equation*}
Dove si intende, ad esempio, $\ket{0}\ket{00}=\ket{0}_{A}\ket{0}_{A}\ket{0}_{B}$.\\
Poi viene applicata una porta \texttt{CNOT} usando il primo qubit A come bit di controllo e il secondo qubit B come bit target (se vediamo i qubit come $\ket{000}$ sarebbe $C_{1}NOT_{3}$)
\begin{equation*}
    \ket{\psi_{0}} \xrightarrow{C_{1}NOT_{2}} \ket{\psi_{1}} = \frac{1}{\sqrt{2}}\left[\alpha\ket{0}(\ket{00}+\ket{11})+\beta\ket{1}(\ket{01}+\ket{10})\right]
\end{equation*}
Successivamente Alice applica una porta di Hadarmard al primo qubit
\begin{equation*}
    \begin{split}
        \ket{\psi_{1}} \xrightarrow{H_{1}} \ket{\psi_{2}}& = \frac{1}{2}\left[\alpha(\ket{0}+\ket{1})(\ket{00}+\ket{11})+\beta(\ket{0}-\ket{1})(\ket{01}+\ket{10})\right] \\ &
        = \frac{1}{2}\left[\ket{00}(\alpha\ket{0}+\beta\ket{1})+\ket{01}(\alpha\ket{1}+\beta\ket{0})+\ket{10}(\alpha\ket{0}-\beta\ket{1})+\ket{11}(\alpha\ket{1}-\beta\ket{0})\right]
    \end{split}
\end{equation*}
l'ultimo passo è quindi quello di rendere tale informazione accessibile a Bob. Per fare questo, Alice misura i suoi due qubit e dato che i qubit di Alice e Bob sono entangled, la  misura di Alice induce un collasso dello stato di Bob. I possibili risultati della misura di Alice e i corrispondenti stati di Bob sono
\begin{center}
    \begin{tabular}{| c | c | c | c |}
        \hline
        \textbf{Misura} & \textbf{Stato di Bob} & \textbf{Probabilità di misurare 0} & \textbf{Probabilità di misurare 1}\\
        \hline
        00 & $\alpha\ket{0}+\beta\ket{1}$ & $\mathcal{P}_{00}(0) = \lvert \alpha \rvert^{2}$ & $\mathcal{P}_{00}(1) = \lvert \beta \rvert^{2}$\\
        \hline
        01 & $\alpha\ket{1}+\beta\ket{0}$ & $\mathcal{P}_{01}(0) = \lvert \beta \rvert^{2}$ & $\mathcal{P}_{01}(1) = \lvert \alpha \rvert^{2}$\\
        \hline
        10 & $\alpha\ket{0}-\beta\ket{1}$ & $\mathcal{P}_{10}(0) = \lvert \alpha \rvert^{2}$ & $\mathcal{P}_{10}(1) = \lvert \beta \rvert^{2}$\\
        \hline
        11 & $\alpha\ket{1}-\beta\ket{0}$ & $\mathcal{P}_{11}(0) = \lvert \beta \rvert^{2}$ & $\mathcal{P}_{11}(1) = \lvert \alpha \rvert^{2}$\\
        \hline
    \end{tabular}
\end{center}
Ognuno di queste misure capita con probabilità di $\frac{1}{4}$. Affinchè Bob possegga sempre lo stato $\ket{\psi} = \alpha\ket{0}+\beta\ket{1}$, Alice chiama attraverso un canale classico Bob e gli dice quale è stato il risultato della sua misura. A questo punto Bob applica un'operatore correttivo
\begin{center}
    \begin{tabular}{| c | c |}
        \hline
        \textbf{Misura} & \textbf{Operatore correttivo} \\
        \hline
        00 & $I$ \\
        \hline
        01 & $X$ \\
        \hline
        10 & $Z$ \\
        \hline
        11 & $Y$ \\
        \hline
    \end{tabular}
\end{center}
La probabilità totale di misurare 0 per Bob è
\begin{equation*}
    \begin{split}
        \mathcal{P}_{Bob}(0) &= \frac{1}{4}\left(\mathcal{P}_{00}(0)+\mathcal{P}_{01}(0)+\mathcal{P}_{10}(0)+\mathcal{P}_{11}(0)\right) \\
        &= \frac{1}{4}\left(\lvert \alpha \rvert^{2}+ \lvert \beta \rvert^{2} +\lvert \alpha \rvert^{2}+ \lvert \beta \rvert^{2}\right) \\
        &= \frac{1}{4}(1+1) = \frac{1}{2}
    \end{split}
\end{equation*}
Stessa cosa per $\mathcal{P}_{Bob}(1)=\frac{1}{2}$.\\
La conclusione è che sebbene Alice abbia modificato lo stato (o gli stati) di Bob, quest'ultimo non è in grado di estrarre nessuna informazione.
\section{Algoritmi quantistici}
\subsection{Algoritmo di Deutch}
Data una funzione $f$ ad un bit, l'algoritmo di Deutch permette di capire se sia costante o no; nel caso in cui $f$ non sia costante viene spesso chiamata \textbf{bilanciata}. Si consideri una funzione ad un bit $f(x):\{0,1\}\rightarrow\{0,1\}$, la funzione $f$ sarà costante se $f(0)=f(1)$ e sarà bilanciata se $f(0)\neq f(1)$.\\
Lo stato iniziale dell'algoritmo di Deutch è costituito da due qubit: $\ket{\psi_{0}}=\ket{01}$. Ad entrambi viene applicata una porta di Hadarmard per  ottenere
\begin{equation*}
    \ket{\psi_{0}}\rightarrow\ket{\psi_{1}} = \frac{1}{2}\left(\ket{0}+\ket{1}\right)\left(\ket{0}-\ket{1}\right)
\end{equation*}
\subsubsection{L'operatore $U_{f}$}
L'effetto di questo operatore è quello di calcolare $f(x)$, l'addizione modulo 2 di $y\oplus f(x)$ e lo possa immagazzinare nel secondo qubit ($\ket{x,y}\rightarrow\ket{x,y\oplus f(x)}$). L'addizione modulo 2 è equivalente ad una porta \texttt{XOR}.\\
Per capire come agisce l'operatore $U_{f}$, nell'algoritmo di Deutch, lo applichiamo ad uno stato generico $\ket{x}\ket{-}$:
\begin{equation*}
    \begin{split}
        \ket{x}\ket{-} = \ket{x}\frac{\ket{0}-\ket{1}}{\sqrt{2}} &\xrightarrow{U_{f}}_{x=0} \ket{0}\frac{\ket{0}-\ket{1}}{\sqrt{2}} = \frac{1}{\sqrt{2}}\left(\ket{00}-\ket{01}\right)\\
        &\xrightarrow{U_{f}} \frac{1}{\sqrt{2}}\left(\ket{0,0\oplus f(0)}-\ket{0,1\oplus f(0)}\right) = \begin{cases}
            \frac{1}{\sqrt{2}}\left(\ket{00}-\ket{01}\right) = \ket{0}\ket{-} & \text{se $f(0)=0$} \\
            \frac{1}{\sqrt{2}}\left(\ket{01}-\ket{00}\right) = -\ket{0}\ket{-} & \text{se $f(0)=1$}
        \end{cases}
    \end{split}
\end{equation*}
In sostanza, l'applicazione dell'operatore $U_{f}$ lascia invariato sia il primo qubit che il secondo ma lo stato acquista una fase $(-1)^{f(x)}$ che dipende dal  valore della funzione $f$ calcolata per $x$:
\begin{equation*}
    \ket{x}\frac{\ket{0}-\ket{1}}{\sqrt{2}}\rightarrow(-1)^{f(x)}\ket{x}\frac{\ket{0}-\ket{1}}{\sqrt{2}}
\end{equation*} 
Possiamo dire che lo stato $\ket{x}\frac{\ket{0}-\ket{1}}{\sqrt{2}}$ è un autovettore dell'operatore $U_{f}$ con autovalore $(-1)^{f(x)}$.\\
Tornando allo stato iniziale $\ket{\psi_{1}}$, applichiamo l'operatore $U_{f}$ e una porta di Hadarmard sul primo qubit per ottenere
\begin{equation*}
    \begin{split}
        \ket{\psi_{2}} = U_{f}\ket{\psi_{1}} &= \frac{1}{\sqrt{2}}\left((-1)^{f(0)}\ket{0}+(-1)^{f(1)}\ket{1}\right) \\ 
        &\xrightarrow{H_{1}} \frac{1}{2}\left[\ket{0}\left((-1)^{f(0)}+(-1)^{f(1)}\right)+\ket{1}\left((-1)^{f(0)}-(-1)^{f(1)}\right)\right]
    \end{split}
\end{equation*}
Se la funzione è costante avremo che $(-1)^{f(0)}+(-1)^{f(1)}=2$ e $(-1)^{f(0)}-(-1)^{f(1)}=0$ quindi $\ket{\psi_{2}}=\ket{0}$. Al contrario se la funzione è bilanciata avremo che $(-1)^{f(0)}+(-1)^{f(1)}=0$ e $(-1)^{f(0)}-(-1)^{f(1)}=\pm2$ quindi $\ket{\psi_{2}}=\pm\ket{1}$ e visto che il segno $\pm$ può essere visto come fase globale, possiamo dire che lo stato finale è $\ket{1}$.
\customfbox{L'algoritmo di Deutch permette di migliorare le performance dell'algoritmo classico perchè usa il parallelismo quantistico.}
\subsection{Algoritmo di Deutch-Josza}
\subsection{Algoritmo di Bernstein-Vazirani}
\end{document}